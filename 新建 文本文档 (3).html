<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¢å¼ºäº¤äº’ç²’å­ç³»ç»Ÿ - Three.js & MediaPipe</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* æ‘„åƒå¤´é¢„è§ˆ - å·¦ä¸‹è§’ï¼Œå¸¦å…‰æ™• */
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.2);
            z-index: 10;
            background: #000;
        }
        
        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            opacity: 0.8;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #00ffff;
            font-size: 18px;
            text-align: center;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
            transition: opacity 0.5s;
        }
        
        .ui-instruction {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255,255,255,0.8);
            pointer-events: none;
            user-select: none;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
        h2 { margin: 0 0 10px 0; font-size: 1.2rem; color: #fff; }
        p { margin: 5px 0; font-size: 0.9rem; }
        .key { color: #00ffff; font-weight: bold; }
    </style>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loading">
        æ­£åœ¨åŠ è½½è§†è§‰æ¨¡å‹...<br>
        <small>è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¯ç”¨æ‰‹åŠ¿æ§åˆ¶</small>
    </div>
    
    <div class="ui-instruction">
        <h2>âœ¨ äº¤äº’æŒ‡å—</h2>
        <p>ğŸ‘Œ <span class="key">æåˆæ‰‹æŒ‡</span>: æåº¦ç¼©å° (å‡èš)</p>
        <p>ğŸ– <span class="key">å¼ å¼€æ‰‹æŒ</span>: æ‰©æ•£çˆ†å‘ & å˜è‰²</p>
    </div>

    <div id="video-container">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
        import { FilesetResolver, HandLandmarker } from '@mediapipe/tasks-vision';

        // --- é…ç½®å‚æ•° ---
        const CONFIG = {
            count: 20000,           // ç²’å­æ•°é‡
            size: 0.12,             // ç²’å­åŸºç¡€å¤§å°
            shape: 'Heart',         // é»˜è®¤å½¢çŠ¶
            
            // é¢œè‰²äº¤äº’
            colorRest: '#0088ff',   // é™æ¯é¢œè‰² (æåˆæ—¶)
            colorActive: '#ff0055', // æ¿€æ´»é¢œè‰² (å¼ å¼€æ—¶)
            
            // å†…éƒ¨çŠ¶æ€å˜é‡
            handInfluence: 0,       // 0=æåˆ, 1=å¼ å¼€ (å¹³æ»‘å)
            autoRotateSpeed: 1.0,   // åŸºç¡€æ—‹è½¬é€Ÿåº¦
        };

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 35;
        camera.position.y = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = CONFIG.autoRotateSpeed;

        // --- ç²’å­ç³»ç»Ÿ ---
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(CONFIG.count * 3);
        const originalPositions = new Float32Array(CONFIG.count * 3);
        const randomOffsets = new Float32Array(CONFIG.count * 3); // æ¯ä¸ªç²’å­çš„éšæœºåç§»é‡

        for (let i = 0; i < CONFIG.count * 3; i++) {
            positions[i] = 0;
            // é¢„å…ˆè®¡ç®—å™ªç‚¹ï¼Œé¿å…æ¯å¸§è®¡ç®—Math.random
            randomOffsets[i] = (Math.random() - 0.5) * 2; 
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: CONFIG.colorRest,
            size: CONFIG.size,
            blending: THREE.AdditiveBlending,
            depthTest: false,
            transparent: true,
            opacity: 0.9,
            sizeAttenuation: true
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- å½¢çŠ¶ç”Ÿæˆç®—æ³• ---
        const Shapes = {
            Planet: () => {
                const r = 12;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                return {
                    x: r * Math.sin(phi) * Math.cos(theta),
                    y: r * Math.sin(phi) * Math.sin(theta),
                    z: r * Math.cos(phi)
                };
            },
            Saturn: () => {
                const isRing = Math.random() > 0.65;
                let x, y, z;
                if (!isRing) {
                    const r = 9;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos(2 * Math.random() - 1);
                    x = r * Math.sin(phi) * Math.cos(theta);
                    y = r * Math.sin(phi) * Math.sin(theta);
                    z = r * Math.cos(phi);
                } else {
                    const r = 14 + Math.random() * 8;
                    const theta = Math.random() * Math.PI * 2;
                    x = r * Math.cos(theta);
                    z = r * Math.sin(theta);
                    y = (Math.random() - 0.5);
                    // Tilt
                    const tilt = 0.4;
                    const ty = y * Math.cos(tilt) - x * Math.sin(tilt);
                    const tx = y * Math.sin(tilt) + x * Math.cos(tilt);
                    x = tx; y = ty;
                }
                return { x, y, z };
            },
            Heart: () => {
                // ç»å…¸3Då¿ƒå½¢å…¬å¼
                let x = (Math.random() - 0.5) * 40;
                let y = (Math.random() - 0.5) * 40;
                let z = (Math.random() - 0.5) * 40;
                
                // æ‹’ç»é‡‡æ ·æ³•è·å¾—æ›´å‡åŒ€çš„å¿ƒå½¢å†…éƒ¨
                // ç®€åŒ–ç‰ˆï¼šå‚æ•°æ–¹ç¨‹
                const t = Math.random() * Math.PI * 2; // 0 to 2PI
                const u = Math.random() * Math.PI; // 0 to PI
                
                // ä¿®æ­£åçš„å¿ƒå½¢ç¼©æ”¾
                const scale = 0.8;
                x = 16 * Math.pow(Math.sin(t), 3) * Math.sin(u) * scale;
                y = (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * Math.sin(u) * scale;
                z = 6 * Math.cos(u) * scale; // å¢åŠ åšåº¦
                
                return { x, y, z };
            },
            Flower: () => {
                const u = Math.random() * Math.PI * 2;
                const v = Math.random() * Math.PI;
                const r = 10 * (1 + 0.5 * Math.sin(5 * u) * Math.sin(v)); // 5 petals
                return {
                    x: r * Math.sin(v) * Math.cos(u),
                    y: r * Math.sin(v) * Math.sin(u),
                    z: r * Math.cos(v) * 0.5
                };
            },
            DNA: () => {
                const h = (Math.random() - 0.5) * 40; // Height
                const helix = Math.random() > 0.5 ? 1 : -1; // Double helix
                const theta = h * 0.5 + (helix * Math.PI);
                const r = 6 + Math.random();
                return {
                    x: r * Math.cos(theta),
                    y: h,
                    z: r * Math.sin(theta)
                };
            },
            Buddha: () => {
                // ç®€å•çš„çƒä½“ç»„åˆæ¨¡æ‹Ÿæ‰“åå½¢æ€
                const p = Math.random();
                let x,y,z;
                if(p < 0.25) { // Head
                    const r=3; const t=Math.random()*6.28; const f=Math.acos(2*Math.random()-1);
                    x=r*Math.sin(f)*Math.cos(t); y=r*Math.sin(f)*Math.sin(t)+8; z=r*Math.cos(f);
                } else if (p < 0.6) { // Body
                    const r=6; const t=Math.random()*6.28; const f=Math.acos(2*Math.random()-1);
                    x=r*Math.sin(f)*Math.cos(t)*1.1; y=r*Math.sin(f)*Math.sin(t)*0.9 - 1; z=r*Math.cos(f)*0.8;
                } else { // Legs base
                    const r=9; const t=Math.random()*6.28; 
                    x=r*Math.cos(t); y=(Math.random()-0.5)*2 - 7; z=r*Math.sin(t)*0.7;
                }
                return {x,y,z};
            }
        };

        function setShape(shapeName) {
            const generator = Shapes[shapeName] || Shapes.Heart;
            for (let i = 0; i < CONFIG.count; i++) {
                const pos = generator();
                originalPositions[i*3] = pos.x;
                originalPositions[i*3+1] = pos.y;
                originalPositions[i*3+2] = pos.z;
            }
        }
        setShape(CONFIG.shape);

        // --- MediaPipe æ‰‹åŠ¿é€»è¾‘ ---
        let handLandmarker = null;
        let lastVideoTime = -1;
        const video = document.getElementById('webcam');

        async function initVision() {
            try {
                const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
                handLandmarker = await HandLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1 // ä¸“æ³¨å•æ‰‹æ§åˆ¶
                });
                
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    document.getElementById('loading').style.opacity = 0;
                });
            } catch(e) {
                document.getElementById('loading').innerHTML = "æ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–æ¨¡å‹åŠ è½½å¤±è´¥";
            }
        }
        initVision();

        // --- UI é¢æ¿ ---
        const gui = new GUI({ title: 'æ§åˆ¶å°' });
        gui.add(CONFIG, 'shape', Object.keys(Shapes)).name('æ¨¡å‹é€‰æ‹©').onChange(setShape);
        
        const folderColor = gui.addFolder('äº¤äº’é¢œè‰²');
        folderColor.addColor(CONFIG, 'colorRest').name('å‡èšé¢œè‰² (é™)').onChange(c => material.color.set(c));
        folderColor.addColor(CONFIG, 'colorActive').name('çˆ†å‘é¢œè‰² (åŠ¨)');
        
        gui.add(CONFIG, 'size', 0.05, 0.4).name('ç²’å­å¤§å°').onChange(v => material.size = v);

        // --- åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();
        const tempColor = new THREE.Color();
        const colorRest = new THREE.Color();
        const colorActive = new THREE.Color();

        function animate() {
            requestAnimationFrame(animate);

            // 1. è§†è§‰æ£€æµ‹
            if (handLandmarker && video.currentTime !== lastVideoTime && video.readyState >= 2) {
                lastVideoTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, performance.now());
                
                if (result.landmarks && result.landmarks.length > 0) {
                    const hand = result.landmarks[0];
                    // è®¡ç®—æ‹‡æŒ‡(4)ä¸é£ŸæŒ‡(8)çš„è·ç¦»
                    const dx = hand[4].x - hand[8].x;
                    const dy = hand[4].y - hand[8].y;
                    const dz = hand[4].z - hand[8].z; 
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    
                    // æ˜ å°„é€»è¾‘ï¼š
                    // dist é€šå¸¸åœ¨ 0.02 (æåˆ) åˆ° 0.15 (å¼ å¼€) ä¹‹é—´ (è§†è·ç¦»è€Œå®š)
                    // æˆ‘ä»¬åšä¸€ä¸ªç›¸å¯¹å®½å®¹çš„æ˜ å°„
                    const rawVal = THREE.MathUtils.mapLinear(dist, 0.03, 0.15, 0, 1);
                    const clampedVal = THREE.MathUtils.clamp(rawVal, 0, 1);
                    
                    // å¹³æ»‘è¿‡æ¸¡
                    CONFIG.handInfluence += (clampedVal - CONFIG.handInfluence) * 0.15;
                } else {
                    // æ— æ‰‹æ—¶ï¼Œç¼“æ…¢å›åˆ°ä¸­é—´çŠ¶æ€æˆ–é™æ¯æ€
                    CONFIG.handInfluence += (0.3 - CONFIG.handInfluence) * 0.05;
                }
            }

            const influence = CONFIG.handInfluence;

            // 2. äº¤äº’é€»è¾‘è®¡ç®—
            
            // A. ç¼©æ”¾é€»è¾‘ (è¦æ±‚ï¼šç¼©å°ç¨‹åº¦æ›´å¤§)
            // å½“ influence = 0 (æåˆ), scale = 0.2 (æå°)
            // å½“ influence = 1 (å¼ å¼€), scale = 4.0 (å·¨å¤§)
            const scaleBase = 0.2; 
            const scaleMax = 4.0;
            const currentScale = THREE.MathUtils.lerp(scaleBase, scaleMax, influence);

            // B. é¢œè‰²é€»è¾‘
            colorRest.set(CONFIG.colorRest);
            colorActive.set(CONFIG.colorActive);
            // é¢œè‰²åœ¨ influence 0.2 åˆ° 0.8 ä¹‹é—´æ¸å˜
            material.color.lerpColors(colorRest, colorActive, influence);

            // C. æ—‹è½¬é€Ÿåº¦é€»è¾‘
            // å¼ å¼€æ—¶è½¬å¾—å¿«
            controls.autoRotateSpeed = 1.0 + influence * 8.0; 

            // 3. ç²’å­ä½ç½®æ›´æ–°
            const posArr = particles.geometry.attributes.position.array;
            const time = clock.getElapsedTime();

            for(let i = 0; i < CONFIG.count; i++) {
                const idx = i * 3;
                
                // åŸå§‹å½¢çŠ¶ä½ç½®
                const ox = originalPositions[idx];
                const oy = originalPositions[idx+1];
                const oz = originalPositions[idx+2];

                // å™ªç‚¹æ‰©æ•£ (å¼ å¼€æ—¶å™ªç‚¹å¤§)
                const noiseAmp = influence * 3.5;
                const nx = randomOffsets[idx] * noiseAmp;
                const ny = randomOffsets[idx+1] * noiseAmp;
                const nz = randomOffsets[idx+2] * noiseAmp;

                // å‘¼å¸æ•ˆæœ (ç»™é™æ¯æ€ä¸€ç‚¹ç”Ÿæ°”)
                const breath = 1 + Math.sin(time * 2 + i) * 0.02;

                // ç›®æ ‡ä½ç½®è®¡ç®—
                const tx = ox * currentScale * breath + nx;
                const ty = oy * currentScale * breath + ny;
                const tz = oz * currentScale * breath + nz;

                // Lerp æ›´æ–°ä½ç½®
                posArr[idx] += (tx - posArr[idx]) * 0.1;
                posArr[idx+1] += (ty - posArr[idx+1]) * 0.1;
                posArr[idx+2] += (tz - posArr[idx+2]) * 0.1;
            }
            
            particles.geometry.attributes.position.needsUpdate = true;

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();

    </script>
</body>
</html>